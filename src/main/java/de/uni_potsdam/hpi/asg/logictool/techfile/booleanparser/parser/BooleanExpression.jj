/* * Copyright (C) 2014 - 2015 Norman Kluge *  * This file is part of ASGlogic. *  * ASGlogic is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. *  * ASGlogic is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. *  * You should have received a copy of the GNU General Public License * along with ASGlogic.  If not, see <http://www.gnu.org/licenses/>. */options{  JDK_VERSION = "1.5";  static = false;}PARSER_BEGIN(BooleanExpressionParser)package de.uni_potsdam.hpi.asg.logictool.techfile.booleanparser.parser;import de.uni_potsdam.hpi.asg.logictool.techfile.booleanparser.model.*;import de.uni_potsdam.hpi.asg.logictool.techfile.booleanparser.model.TechBinaryOperation.TechBinaryOperator;import de.uni_potsdam.hpi.asg.logictool.techfile.booleanparser.model.TechUnaryOperation.TechUnaryOperator;import java.util.Map;import java.util.HashMap;import java.io.InputStream;@SuppressWarnings("all")public class BooleanExpressionParser {  public static Map<String, TechVariable> vars = new HashMap < String, TechVariable > ();

  public static Map<String, TechVariable> getVars() {    return vars;
  }
}PARSER_END(BooleanExpressionParser)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* OPERATORS */{  < OR : "+" >| < AND : "*" >| < NOT : "!" >}TOKEN :{  < VARIABLE : (< ALPHA >)+ >| < #ALPHA : [ "A"-"Z", "a"-"z", "0"-"9" ] >| < LPAREN : "(" >| < RPAREN : ")" >| < SEMICOLON : ";" >}public TechTerm parse() :{  TechTerm t;}{  t = expr() < SEMICOLON >  {    return t;  }}private TechTerm expr() :{  TechTerm t1, t2;
  TechBinaryOperator op;}{  t1 = term()  (    < OR >    {      op = TechBinaryOperator.or;    }    t2 = expr()    {      return new TechBinaryOperation(t1, op, t2);    }  )?  {    return t1;  }}private TechTerm term() :{  TechTerm t1, t2;
  TechBinaryOperator op;}{  t1 = primary()  (    < AND >    {      op = TechBinaryOperator.and;    }    t2 = term()    {      return new TechBinaryOperation(t1, op, t2);    }  )?  {    return t1;  }}private TechTerm primary() :{  TechTerm t;}{  (    t = variable()    {      return t;    }  |     t = braces()    {      return t;    }  | t = unary()    {      return t;    }  )}private TechTerm braces() :{  TechTerm t;}{  < LPAREN > t = expr() < RPAREN >  {    return t;  }}private TechTerm unary() :{  TechTerm t;}{  < NOT > t = primary()  {    return new TechUnaryOperation(t, TechUnaryOperator.not);  }}private TechTerm variable() :{  String s;}{  s = < VARIABLE >.image  {    if (vars.containsKey(s))    {      return vars.get(s);    }    else    {      TechVariable v = new TechVariable(s);      vars.put(s, v);      return v;    }  }}
